<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Creating packages</title>
    <meta charset="utf-8" />
    <meta name="author" content="Niklas Pawelzik and Fabian Pawelczyk" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="simons-touch.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Creating packages
]
.subtitle[
## using devtools and usethis
]
.author[
### Niklas Pawelzik and Fabian Pawelczyk
]
.institute[
### <a href="https://github.com/intro-to-data-science-22-workshop/19-creating-packages-pawelzik-pawelczyk">Hertie School MDS cohort 2024</a>
]
.date[
### 2022/11/15(updated: 2022-11-15)
]

---


&lt;style type="text/css"&gt;
@media print { # print out incremental slides; see https://stackoverflow.com/questions/56373198/get-xaringan-incremental-animations-to-print-to-pdf/56374619#56374619
  .has-continuation {
    display: block !important;
  }
}
&lt;/style&gt;




# Table of contents

&lt;br&gt;


1. [Packages and Functions](#packages)

2. [Iteration](#commands)

3. [Strategies for debugging](#debugging)

4. [Debugging R](#debuggingr)




&lt;!-- ############################################ --&gt;
---
class: inverse, center, middle
name: packages

# Packages

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px style="width:1000px; margin:auto;"/&gt;&lt;/html&gt;


---

# What is a package?

Let us ask some experts, namely Hadley Wickham and Jenny Bryan in [R Packages](https://r-pkgs.org/whole-game.html):

&gt; Packages are the fundamental units of reproducible R code. They include reusable R functions, the documentation that describes how to use them, and sample data.

--

Put it very simple: packages are a bundle of **functions**. However, they offer us more than that e.g. adding function **descriptions**, **datasets** or even new **data-types**.

&lt;!-- 
- Pipes (you already know that âœ…)
- User-generated functions
- Functional programming with `purrr` --&gt;

--

We will now learn the basics of creating our own packages with R. But we need to check some boxes first:

- What was a function again?
- Why do I need packages?
- How do I build packages


---
# Detour: Functions
.pull-left[
Why functions? Because they have the potential to save enormous amount of time and therefore gives us more time to think about more substantial questions. A function usually consists of:

- A function **name** that informas the user about the function's purpose
- **ARGUMENTS** to the function that controlling the output of a function
- **BODY** that represents all the code used inside
- **return value**: what should the function return?

--


```r
R&gt; name &lt;- function(ARGUMENTS) {
+     BODY
+     return(VALUE)
+   }
```
]

--

.pull-right[
Let's look briefly at an example function - one that coverts any value to it's squared value.


```r
R&gt; sq &lt;- function(x) {
+   stopifnot("input must be numeric" = is.numeric(x))
+   x_squared &lt;- x^2
+   return(x_squared)
+ }
```
]

---
# Creating packages

### Why creating packages?

There are 18,000+ **packages** on CRAN. Sounds to be a quite popular way to go, right? 

People usually build packages to save time. For instance, some institutions have a corporate identity, so they always use charts in specific colours and often make use of their logo somewhere --&gt; this could also be part of a package.

In general arguments very analogue to the ones for using functions: Let's assume you want to get the clean text data from parliamentary speeches to run a NLP model --&gt; Instead of applying multiple steps on each document, e.g. downloading the stenographic reports, rename the documents manually and retrieve the relevant text data from pdf -&gt; we build a function that runs all these steps on each document automatically and outputs us a clean data frame with all relevant variables such as text, speaker etc. .-&gt; Easy to see the advantage of the function timewise.

--

Two weeks later we want to run a similar task on parliamentary speeches from another country... It would be obvious to reuse functions from last time and/or adjust some of the functions we already used. We should write a package!

--

Recap: you write packages in order to... 

-  Don't repeat yourself and be more efficient

- share workflows and empower yourself AND others

- functions make your work easier, faster and more reproducible. R packages let you share these functions

---

### The anatomy of a pckage

* **Metadata** via the `DESCRIPTION`, including the name of the package, description of the package, the version of the package, and any package dependencies  

--

* **Source code** via `.R` files, that live in the `R/` directory.  

--

* Special `roxygen` comments inside the `.R` files that describe how the function operates and its arguments, dependencies, and other metadata  

--

* The **namespace** for the *exported functions* you have written, and the *imported functions* you bring in  

--

* Tests that confirm your function "works as intended"  

--

* Other things (installed files, compiled code, data, tutorials, vignettes)

---
# Creating packages

### Writing packages using packages

* [`devtools`](https://devtools.r-lib.org/):  

&gt; The aim of devtools is to make package development easier by providing R functions that simplify and expedite common tasks.
--

* [`usethis`](https://usethis.r-lib.org/)  

&gt; usethis is a workflow package: it automates repetitive tasks that arise during project setup and development, both for R packages and non-package projects.

---

# Relevant commands: _create_package()_
### Create a blank package

Can call `usethis::create_package()` or use the RStudio GUI.

![A gif of using the RStudio IDE to create a new blank package.](https://raw.githubusercontent.com/jthomasmock/pkg-building/master/images/rstudio-create-pkg.gif)

---

# Relevant commands: _use_r()_

Where do we want to define our function? We want to save it in an `.R` file in our `R/` subdirectory folder of our package (we saw this above already). For beginners it is recommended to create a new `.R` file for each function of our package and name the file similar to the function. More advanced user begin to group related functions together. In order to save our first function we can simply use the following syntax:

--


```r
R&gt; usethis::use_r("sq")
```

---

# Relevant commands: _use_r()_

Where do we want to define our function? We want to save it in an `.R` file in our `R/` subdirectory folder of our package (we saw this above already). For beginners it is recommended to create a new `.R` file for each function of our package and name the file similar to the function. More advanced user begin to group related functions together. In order to save our first function we can simply use the following syntax:


```r
R&gt; usethis::use_r("sq")
```

```
   v Setting active project to 'C:/Users/fpawe/OneDrive - Hertie School/hertie_study/intro_data_science/19-creating-packages-pawelzik-pawelczyk'
   * Edit 'R/sq.R'
   * Call `use_test()` to create a matching test file
```


Note: After executing the use_r() command we can use our function although it is not defined in our global environment. We already get some package-vibes here, right? 
Also, put **only** the definition of our new function (in this case`sq()`) into the `R/sq.R` file and save it. Otherwise one can easily run into problems.

---
# Relevant commands: _use_r()_



# Relevant commands: _check()_

How can we ensure that our example function `sq()` works?... do this part later


```r
R&gt; devtools::check()
```
Why does this not work

--



###



---

# Basic syntax

.pull-left[
Writing your own function in R is easy with the `function()` function&lt;sup&gt;1&lt;/sup&gt;. The basic syntax is as follows:


```r
*R&gt; my_func &lt;- function(ARGUMENTS) {
+     OPERATIONS
+     return(VALUE)
+   }
```

- We write functions to apply them later. So, we have to give them a name. Here, we name it "`my_func`".
- Also, our function (almost) always needs input, plus we want to specify how exactly the function should behave. We can use arguments for this, which are specified as arguments of the `function()` function.

.footnote[&lt;sup&gt;1&lt;/sup&gt; Yes, a function to create functions. ðŸ¤¯]
]

---

# Basic syntax

.pull-left[
Writing your own function in R is easy with the `function()` function&lt;sup&gt;1&lt;/sup&gt;. The basic syntax is as follows:


```r
R&gt; my_func &lt;- function(ARGUMENTS) {
*+     OPERATIONS
+     return(VALUE)
+   }
```

- Next, we specify anything we want the function to to.
- This comes in between curly brackets, `{...}`.
- Importantly, we can recycle arguments by calling them by their name.

.footnote[&lt;sup&gt;1&lt;/sup&gt; Yes, a function to create functions. ðŸ¤¯]
]

---

# Basic syntax

.pull-left[
Writing your own function in R is easy with the `function()` function&lt;sup&gt;1&lt;/sup&gt;. The basic syntax is as follows:


```r
R&gt; my_func &lt;- function(ARGUMENTS) {
+     OPERATIONS 
*+     return(VALUE)
+   }
```

- Finally, we specify what the function should return. 
- This could be a list, data.frame, vector, sentence - or anything else really.
- Note that R automatically returns the final object that is written (not: assigned!) in your function by default. Still, my recommendation is that you get into the habit of assigning the return object(s) explicitly with `return()`.

.footnote[&lt;sup&gt;1&lt;/sup&gt; Yes, a function to create functions. ðŸ¤¯]
]

---

# Basic syntax

.pull-left[
Writing your own function in R is easy with the `function()` function&lt;sup&gt;1&lt;/sup&gt;. The basic syntax is as follows:


```r
R&gt; my_func &lt;- function(ARGUMENTS) {
+     OPERATIONS 
+     return(VALUE) 
*+   }
```

- Oh, and don't forget to close the curly brackets...

.footnote[&lt;sup&gt;1&lt;/sup&gt; Yes, a function to create functions. ðŸ¤¯]
]

---

# Basic syntax

.pull-left[
Writing your own function in R is easy with the `function()` function&lt;sup&gt;1&lt;/sup&gt;. The basic syntax is as follows:


```r
R&gt; my_func &lt;- function(ARGUMENTS) {
+     OPERATIONS 
+     return(VALUE) 
+   } 
```

.footnote[&lt;sup&gt;1&lt;/sup&gt; Yes, a function to create functions. ðŸ¤¯]
]

.pull-right[
Let's try it out with a simple example function - one that converts temperatures from [Fahrenheit to Celsius](https://en.wikipedia.org/wiki/Conversion_of_scales_of_temperature#Fahrenheit):&lt;sup&gt;2&lt;/sup&gt;


```r
R&gt; fahrenheit_to_celsius &lt;- function(temp_F) {
+   temp_C &lt;- (temp_F - 32) * (5/9)
+   return(temp_C)
+ }
```

.footnote[&lt;sup&gt;2&lt;/sup&gt; Courtesy of [Software Carpentry](https://swcarpentry.github.io/r-novice-inflammation/02-func-R/).]

]

---

# Basic syntax

.pull-left[
Writing your own function in R is easy with the `function()` function&lt;sup&gt;1&lt;/sup&gt;. The basic syntax is as follows:


```r
R&gt; my_func &lt;- function(ARGUMENTS) {
+     OPERATIONS 
+     return(VALUE) 
+   } 
```

.footnote[&lt;sup&gt;1&lt;/sup&gt; Yes, a function to create functions. ðŸ¤¯]
]

.pull-right[
Let's try it out with a simple example function - one that converts temperatures from [Fahrenheit to Celsius](https://en.wikipedia.org/wiki/Conversion_of_scales_of_temperature#Fahrenheit):&lt;sup&gt;2&lt;/sup&gt;


```r
*R&gt; fahrenheit_to_celsius &lt;- function(temp_F) {
+   temp_C &lt;- (temp_F - 32) * (5/9)
+   return(temp_C)
+ }
```

- Our function has an intuitive name.
- Also, it takes just one thing as input, which we call `temp_F`.

.footnote[&lt;sup&gt;2&lt;/sup&gt; Courtesy of [Software Carpentry](https://swcarpentry.github.io/r-novice-inflammation/02-func-R/).]

]

---

# Basic syntax

.pull-left[
Writing your own function in R is easy with the `function()` function&lt;sup&gt;1&lt;/sup&gt;. The basic syntax is as follows:


```r
R&gt; my_func &lt;- function(ARGUMENTS) {
+     OPERATIONS 
+     return(VALUE) 
+   } 
```

.footnote[&lt;sup&gt;1&lt;/sup&gt; Yes, a function to create functions. ðŸ¤¯]
]

.pull-right[
Let's try it out with a simple example function - one that converts temperatures from [Fahrenheit to Celsius](https://en.wikipedia.org/wiki/Conversion_of_scales_of_temperature#Fahrenheit):&lt;sup&gt;2&lt;/sup&gt;


```r
R&gt; fahrenheit_to_celsius &lt;- function(temp_F) {
*+   temp_C &lt;- (temp_F - 32) * (5/9)
+   return(temp_C)
+ }
```

- We now take up the argument `temp_F`, do something with it, and store the output in a new object, `temp_C`.
- Importantly, that object only lives within the function. When the function is run, we cannot access it from the environment.


.footnote[&lt;sup&gt;2&lt;/sup&gt; Courtesy of [Software Carpentry](https://swcarpentry.github.io/r-novice-inflammation/02-func-R/).]

]

---

# Basic syntax

.pull-left[
Writing your own function in R is easy with the `function()` function&lt;sup&gt;1&lt;/sup&gt;. The basic syntax is as follows:


```r
R&gt; my_func &lt;- function(ARGUMENTS) {
+     OPERATIONS 
+     return(VALUE) 
+   } 
```

.footnote[&lt;sup&gt;1&lt;/sup&gt; Yes, a function to create functions. ðŸ¤¯]
]

.pull-right[
Let's try it out with a simple example function - one that converts temperatures from [Fahrenheit to Celsius](https://en.wikipedia.org/wiki/Conversion_of_scales_of_temperature#Fahrenheit):&lt;sup&gt;2&lt;/sup&gt;


```r
R&gt; fahrenheit_to_celsius &lt;- function(temp_F) {
+   temp_C &lt;- (temp_F - 32) * (5/9)
*+   return(temp_C)
+ }
```

- Finally, the output is returned.


.footnote[&lt;sup&gt;2&lt;/sup&gt; Courtesy of [Software Carpentry](https://swcarpentry.github.io/r-novice-inflammation/02-func-R/).]

]

---

# Basic syntax

.pull-left[
Writing your own function in R is easy with the `function()` function&lt;sup&gt;1&lt;/sup&gt;. The basic syntax is as follows:


```r
R&gt; my_func &lt;- function(ARGUMENTS) {
+     OPERATIONS 
+     return(VALUE) 
+   } 
```

.footnote[&lt;sup&gt;1&lt;/sup&gt; Yes, a function to create functions. ðŸ¤¯]
]

.pull-right[
Let's try it out with a simple example function - one that converts temperatures from [Fahrenheit to Celsius](https://en.wikipedia.org/wiki/Conversion_of_scales_of_temperature#Fahrenheit):


```r
R&gt; fahrenheit_to_celsius &lt;- function(temp_F) {
+   temp_C &lt;- (temp_F - 32) * (5/9)
+   return(temp_C)
+ }
```

Now, let's try out the function:
{{content}}
]

--


```r
R&gt; fahrenheit_to_celsius(451)
```

```
   [1] 232.7778
```
{{content}}

--

Pretty hot, isn't it?
{{content}}

---

# Functions: default argument values, if(), else()

.pull-left[

Let's make the function a bit more complex, but also more fun.
]

.pull-right[


```r
R&gt; temp_convert &lt;- 
+   function(temp, from = "f") {
+   if (!(from %in% c("f", "c"))){ 
+     stop("No valid input 
+           temperature specified.")
+   }
+   if (from == "f") {
+     out &lt;- (temp - 32) * (5/9)
+   } else {
+     out &lt;- temp * (9/5) + 32
+   }
+   if((from == "c" &amp; temp &gt; 30) | 
+      (from == "f" &amp; out &gt; 30)) {
+     message("That's damn hot!")
+   }else{
+     message("That's not so hot.")
+   }
+   return(out) # return temperature
+ }
```
]

---

# Functions: default argument values, if(), else()

.pull-left[

Let's make the function a bit more complex, but also more fun.

- By giving `from` a default value (`"f"`), we ensure that the function returns valid output when only the key input, `temp`, is provided.
]

.pull-right[


```r
R&gt; temp_convert &lt;- 
*+   function(temp, from = "f") {
+   if (!(from %in% c("f", "c"))){ 
+     stop("No valid input 
+           temperature specified.")
+   }
+   if (from == "f") {
+     out &lt;- (temp - 32) * (5/9)
+   } else {
+     out &lt;- temp * (9/5) + 32
+   }
+   if((from == "c" &amp; temp &gt; 30) | 
+      (from == "f" &amp; out &gt; 30)) {
+     message("That's damn hot!")
+   }else{
+     message("That's not so hot.")
+   }
+   return(out) # return temperature
+ }
```
]



---

# Functions: default argument values, if(), else()

.pull-left[

Let's make the function a bit more complex, but also more fun.

- By giving `from` a default value (`"f"`), we ensure that the function returns valid output when only the key input, `temp`, is provided.
- `if() {...}` allows us to make conditional statements. Here, we test for the validity of the input for argument `from`.

]

.pull-right[


```r
R&gt; temp_convert &lt;- 
+   function(temp, from = "f") { 
*+   if (!(from %in% c("f", "c"))){
+     stop("No valid input 
+           temperature specified.")
+   }
+   if (from == "f") {
+     out &lt;- (temp - 32) * (5/9)
+   } else {
+     out &lt;- temp * (9/5) + 32
+   }
+   if((from == "c" &amp; temp &gt; 30) | 
+      (from == "f" &amp; out &gt; 30)) {
+     message("That's damn hot!")
+   }else{
+     message("That's not so hot.")
+   }
+   return(out) # return temperature
+ }
```
]


---

# Functions: default argument values, if(), else()

.pull-left[

Let's make the function a bit more complex, but also more fun.

- By giving `from` a default value (`"f"`), we ensure that the function returns valid output when only the key input, `temp`, is provided.
- `if() {...}` allows us to make conditional statements. Here, we test for the validity of the input for argument `from`.
- If the condition is not met, the function breaks and prints a message.

]

.pull-right[


```r
R&gt; temp_convert &lt;- 
+   function(temp, from = "f") { 
+   if (!(from %in% c("f", "c"))){ 
+     stop("No valid input 
*+           temperature specified.")
+   }
+   if (from == "f") {
+     out &lt;- (temp - 32) * (5/9)
+   } else {
+     out &lt;- temp * (9/5) + 32
+   }
+   if((from == "c" &amp; temp &gt; 30) | 
+      (from == "f" &amp; out &gt; 30)) {
+     message("That's damn hot!")
+   }else{
+     message("That's not so hot.")
+   }
+   return(out) # return temperature
+ }
```
]

---

# Functions: default argument values, if(), else()

.pull-left[

Let's make the function a bit more complex, but also more fun.

- By giving `from` a default value (`"f"`), we ensure that the function returns valid output when only the key input, `temp`, is provided.
- `if() {...}` allows us to make conditional statements. Here, we test for the validity of the input for argument `from`.
- If the condition is not met, the function breaks and prints a message.
- We `else()` we specify what to do if the `if()` condition is not met.
]

.pull-right[


```r
R&gt; temp_convert &lt;- 
+   function(temp, from = "f") { 
+   if (!(from %in% c("f", "c"))){ 
+     stop("No valid input 
+           temperature specified.")
+   }
+   if (from == "f") {
+     out &lt;- (temp - 32) * (5/9)
*+   } else {
+     out &lt;- temp * (9/5) + 32
+   }
+   if((from == "c" &amp; temp &gt; 30) | 
+      (from == "f" &amp; out &gt; 30)) {
+     message("That's damn hot!")
+   }else{
+     message("That's not so hot.")
+   }
+   return(out) # return temperature
+ }
```
]

---

# Functions: default argument values, if(), else()

.pull-left[

Let's make the function a bit more complex, but also more fun.

- By giving `from` a default value (`"f"`), we ensure that the function returns valid output when only the key input, `temp`, is provided.
- `if() {...}` allows us to make conditional statements. Here, we test for the validity of the input for argument `from`.
- If the condition is not met, the function breaks and prints a message.
- We `else()` we specify what to do if the `if()` condition is not met.
- Make R more talkative with `message()`. Future-You will like it!
]

.pull-right[


```r
R&gt; temp_convert &lt;- 
+   function(temp, from = "f") { 
+   if (!(from %in% c("f", "c"))){ 
+     stop("No valid input 
+           temperature specified.")
+   }
+   if (from == "f") {
+     out &lt;- (temp - 32) * (5/9)
+   } else {  
+     out &lt;- temp * (9/5) + 32
+   }
+   if((from == "c" &amp; temp &gt; 30) | 
+      (from == "f" &amp; out &gt; 30)) {
*+     message("That's damn hot!")
+   }else{
*+     message("That's not so hot.")
+   }
+   return(out) # return temperature
+ }
```
]


---

# Anonymous functions

In R, functions are objects in their own right. They arenâ€™t automatically bound to a name. If you choose not to give the function a name, you get an **anonymous function**. You use an anonymous function when itâ€™s not worth the effort to give it a name.

--

**Examples:**


```r
R&gt; map(char_vec, function(x) paste(x, collapse = "|")) 
R&gt; integrate(function(x) sin(x) ^ 2, 0, pi)
```



---

# Anonymous functions

In R, functions are objects in their own right. They arenâ€™t automatically bound to a name. If you choose not to give the function a name, you get an **anonymous function**. You use an anonymous function when itâ€™s not worth the effort to give it a name.

As of `R 4.1.0`, there's a new shorthand syntax for anonymous functions: `\(x)`.

--

**Example:**


```r
R&gt; (function (x) {paste(x, 'is awesome!')})('Data science') # old syntax
```

```
   [1] "Data science is awesome!"
```

```r
R&gt; (\(x) {paste(x, 'is awesome!')})('Data science') # new syntax
```

```
   [1] "Data science is awesome!"
```



---

# Anonymous functions

In R, functions are objects in their own right. They arenâ€™t automatically bound to a name. If you choose not to give the function a name, you get an **anonymous function**. You use an anonymous function when itâ€™s not worth the effort to give it a name.

As of `R 4.1.0`, there's a new shorthand syntax for anonymous functions: `\(x)`. This plays along nicely with the (native) pipe when we want to pass content to the RHS but not to the first argument.


---

# Anonymous functions

In R, functions are objects in their own right. They arenâ€™t automatically bound to a name. If you choose not to give the function a name, you get an **anonymous function**. You use an anonymous function when itâ€™s not worth the effort to give it a name.

As of `R 4.1.0`, there's a new shorthand syntax for anonymous functions: `\(x)`. This plays along nicely with the (native) pipe when we want to pass content to the RHS but not to the first argument.

**Example:**


```r
R&gt; mtcars |&gt; subset(cyl == 4) |&gt; (\(x) lm(mpg ~ disp, data = x))()
```



---
# `...` (Dot-dot-dot)

Functions can have a special argument `...` (pronounced *dot-dot-dot*). In other programming languages, this type of argument is often called varargs (short for variable arguments), or ellipsis. With it, a function can take any number of additional arguments. That is potentially very powerful!

A common application is to use `...` to pass those additional arguments on to another function.

--

.pull-left[
**Toy example:**


```r
R&gt; my_list_generator &lt;- function(y, z) {
+   list(y = y, z = z)
+ }
R&gt; 
R&gt; my_list_generator_2 &lt;- function(x, ...) {
+   my_list_generator(...)
+ }
R&gt; 
R&gt; str(my_list_generator_2(x = 1, y = 2, z = 3))
```

```
   List of 2
    $ y: num 2
    $ z: num 3
```
]

--

.pull-right[
**Real-life example:**


```r
R&gt; map(.x, .f, ...)
R&gt; map(mtcars, mean, na.rm = TRUE)
```

Arguments:

- `.x`: A list or atomic vector
- `.f`: A function
- `...`: Additional arguments passed on to the mapped function.

]








&lt;!-- ############################################ --&gt;
---
class: inverse, center, middle
name: commands

# Iteration

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px style="width:1000px; margin:auto;"/&gt;&lt;/html&gt;


---

# Iteration

### The ubiquity of iteration

- Often we have to run the same task over and over again, with minor variations. Examples:
  - Standardize values of a variable
  - Recode all numeric variables in a dataset
  - Running multiple models with varying covariate sets
- A benefit of scripting languages in data (as opposed to point-and-click solutions) is that we can easily automate the process of iteration

--

### Ways to iterate

- A simple approach is to copy-and-paste code with minor modifications (â†’ "[duplicate code](https://en.wikipedia.org/wiki/Duplicate_code)", â†’ "[copy-and-paste programming](https://en.wikipedia.org/wiki/Copy-and-paste_programming)"). This is lazy, error-prone, not very efficient, and violates the "[Don't repeat yourself](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)" (DRY) principle. 
- In R, [vectorization](https://adv-r.hadley.nz/perf-improve.html#vectorise), that is applying a function to every element of a vector at once, already does a good share of iteration for us.
- `for()` [loops](https://r4ds.had.co.nz/iteration.html) are intuitive and straightforward to build, but sometimes not very efficient.
- Finally, we learned about functions. Now, we learn how to unleash their power by applying them to anything we interact with in R at scale.


---

# Iteration with purrr

.pull-left-wide[

### The tidyverse way to iterate

- For *real* functional programming in base R, we can use the `*apply()` family of functions (`lapply()`, `sapply()`, etc.). See [here](https://nsaunders.wordpress.com/2010/08/20/a-brief-introduction-to-apply-in-r/) for an excellent summary.
- In the tidyverse, this functionality comes with the `purrr` package.
- At its core is the `map*()` family of functions. 


### How `purrr` works

- The idea is always to **apply** a function to **x**, where x can be a list, vector, data.frame, or something more complex. 
- The output is then returned as output of a pre-defined type (e.g., a list).
- The set of `map()`-style functions is quite comprehensive; see this [cheat sheet](https://github.com/rstudio/cheatsheets/blob/master/purrr.pdf) for an overview.
]

.pull-right-small-center[
&lt;div align="center"&gt;
&lt;br&gt;
&lt;img src="pics/purrr.png" height=250&gt;
&lt;/div&gt;
]

---

# Iteration with purrr: map()

The `map*()` functions all follow a similar syntax:

&lt;div align="center"&gt;
`map(.x, .f, ...)`
&lt;/div&gt;

We use it to apply a function `.f` to each piece in `.x`. Additional arguments to `.f` can be passed on in `...`.

--

For instance, if we want to identify the object class of every column of a data.frame, we can write:


```r
R&gt; map(starwars, class)
```

```
   $name
   [1] "character"
   
   $height
   [1] "integer"
   
   $mass
   [1] "numeric"
   
   $hair_color
   [1] "character"
   
   $skin_color
   [1] "character"
   
   $eye_color
   [1] "character"
   
   $birth_year
   [1] "numeric"
   
   $sex
   [1] "character"
   
   $gender
   [1] "character"
   
   $homeworld
   [1] "character"
   
   $species
   [1] "character"
   
   $films
   [1] "list"
   
   $vehicles
   [1] "list"
   
   $starships
   [1] "list"
```


---

# Iteration with purrr: map() *cont.*

By default, `map()` returns a list. But we can also use other `map*()`functions to give us an atomic vector of an indicated type (e.g., `map_int()` to return an integer vector) or a data.frame created by row- or column-binding (`map_dfr()`, `map_dfc()`).

The `purrr` function set is quite comprehensive. Be sure to check out the [cheat sheet](https://github.com/rstudio/cheatsheets/blob/master/purrr.pdf) and the [tutorials](https://jennybc.github.io/purrr-tutorial/index.html). You'll survive without `purrr` but you probably don't want to live without it. Together with `dplyr` it's easily the most powerful package for data wrangling in the tidyverse. If you master it, it will save you a lot of time and headaches.

&lt;div align="center"&gt;
&lt;br&gt;
&lt;img src="pics/purrr-cheatsheet.png" height=250&gt;
&lt;img src="pics/purrr-cheatsheet-2.png" height=250&gt;

&lt;/div&gt;



---
class: inverse, center, middle
name: debugging

# Strategies for debugging
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px style="width:1000px; margin:auto;"/&gt;&lt;/html&gt;


---
# What's debugging?

.pull-left[
### Straight from the [Wikipedia](https://en.wikipedia.org/wiki/Debugging)

"Debugging is the process of finding and resolving bugs (defects or problems that prevent correct operation) within computer programs, software, or systems."

### A famous (yet not the first) bug:

The term "bug" was used in an account by computer pioneer [Grace Hopper](https://en.wikipedia.org/wiki/Grace_Hopper) (see on the right). While she was working on a [Mark II](https://en.wikipedia.org/wiki/Harvard_Mark_II) computer at Harvard University, her associates discovered a moth stuck in a relay and thereby impeding operation, whereupon she remarked that they were "debugging" the system. This bug was carefully removed and taped to the log book (see on the right).
]

.pull-right-center[
&lt;div align="center"&gt;
&lt;br&gt;
&lt;img src="pics/grace-hopper.jpg" width="200"/&gt;
&lt;br&gt;
&lt;i&gt;Above:&lt;/i&gt; Grace Hopper, &lt;i&gt;Below:&lt;/i&gt; The bug
&lt;br&gt;
&lt;img src="pics/computer-bug-hopper.jpeg" width="300"/&gt; 
&lt;/div&gt;
]


---
# Why debugging matters

.pull-left-wide[
The Wikipedia [list of software bugs](https://en.wikipedia.org/wiki/List_of_software_bugs) with significant consequences is growing and you don't want to be on it. 

NASA software engineers are [famous for producing bug-free code](https://www.bugsplat.com/blog/less-serious/why-nasa-code-doesnt-crash/). This was learned the hard and costly way though. Some highlights from space:

- 1962: A booster went off course during launch, resulting in the [destruction of NASA Mariner 1](https://www.youtube.com/watch?v=CkOOazEJcUc) . This was the result of the failure of a transcriber to notice an overbar in a handwritten specification for the guidance program, resulting in an incorrect formula the FORTRAN code.
- 1999: [NASA's Mars Climate Orbiter was destroyed](https://www.youtube.com/watch?v=lcYkOh4nweE), due to software on the ground generating commands based on parameters in pound-force (lbf) rather than newtons (N)
- 2004: [NASA's Spirit rover became unresponsive](https://www.youtube.com/watch?v=7V54LRRJaGk) on January 21, 2004, a few weeks after landing on Mars. Engineers found that too many files had accumulated in the rover's flash memory (the problem could be fixed though by deleting unnecessary files, and the Rover lived happily ever after. Until it [froze to death in 2011](https://en.wikipedia.org/wiki/Spirit_(rover)).
]

.pull-right-small[
&lt;div align="center"&gt;
&lt;br&gt;&lt;br&gt;
&lt;img src="pics/nasa-coding-error.png" width="400"/&gt;
&lt;img src="pics/nasa-coding-error-2.png" width="400"/&gt;
&lt;/div&gt;
]


---
# Why debugging matters (cont.)

&lt;div align="center"&gt;
&lt;br&gt;
&lt;img src="pics/excel-error-paper-2.jpeg" height="500"/&gt;
&lt;img src="pics/excel-error-paper.png" height="500"/&gt;
&lt;/div&gt;



---
# Why debugging matters (cont.)

.pull-left-center[
&lt;div align="center"&gt;
&lt;br&gt;
&lt;img src="pics/fb-socsci1-1.png" width="550"/&gt;
&lt;img src="pics/fb-socsci1-2.png" width="550"/&gt;
&lt;img src="pics/fb-socsci1-3.png" width="550"/&gt;
&lt;/div&gt;
`Source` [Washington Post](https://www.washingtonpost.com/technology/2021/09/10/facebook-error-data-social-scientists/)
]


.pull-right-center[
&lt;div align="center"&gt;
&lt;br&gt;
&lt;img src="pics/fb-socsci1-4.png" width="450"/&gt;
&lt;img src="pics/fb-socsci1-5.png" width="450"/&gt;
&lt;/div&gt;
`Source` [Solomon Messing / Twitter](https://twitter.com/solomonmg/status/1436742352039669760)
]



---
# A general strategy for debugging

.pull-left-vsmall[]

.pull-right-wide[
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;

## 1. Google

## 2. Reset

## 3. Debug

## 4. Deter
]


---
# Google

.footnote[&lt;sup&gt;1&lt;/sup&gt;Do you get an error message you don't understand? That's good news actually, because the really nasty bugs come without errors. ]

.pull-left-wide2[
According to [this analysis](https://github.com/noamross/zero-dependency-problems/blob/master/misc/stack-overflow-common-r-errors.md), the most common error types in R are:&lt;sup&gt;1&lt;/sup&gt;

1. `Could not find function` errors, usually caused by typos or not loading a required package.
2. `Error in if` errors, caused by non-logical data or missing values passed to R's `if` conditional statement.
3. `Error in eval` errors, caused by references to objects that don't exist.
4. `Cannot open` errors, caused by attempts to read a file that doesn't exist or can't be accessed.
5. `no applicable method` errors, caused by using an object-oriented function on a data type it doesn't support.
6. `subscript out of bounds` errors, caused by trying to access an element or dimension that doesn't exist
7. Package errors caused by being unable to install, compile or load a package.
]

--

.pull-right-small2[
Whenever you see an error message, start by [googling](https://lmgtfy.app/?q=Error+in+interpretative_method+%3A+%20+%20could+not+find+function+%22interpretative_method%22&amp;iie=1) it. Improve your chances of a good match by removing any variable names or values that are specific to your problem. Also, look for [Stack Overflow](https://stackoverflow.com/questions/tagged/r) posts and list of answers.

&lt;div align="center"&gt;
&lt;img src="pics/google-programming.jpeg" height="250"/&gt;
&lt;/div&gt;

]


---
# Reset

.pull-left[
- If at first you don't succeed, try exactly the same thing again.
- Have you tried turning it off and on again?
- Do you use `rm(list = ls())`? Don't. Packages remain loaded, options and environment variables set, ... all possible sources of error!
- A fresh start clears the workspace, resets options, environment variables, and the path.
]

.pull-right[
&lt;div align="center"&gt;
&lt;img src="pics/restart-r-1.png" width="350"/&gt;&lt;br&gt;
&lt;img src="pics/restart-r-2.png" width="350"/&gt;
&lt;/div&gt;
]


---
# Debug

### Make the error repeatable. 

- Execute the code many times as you consider and reject hypotheses. To make that iteration as quick possible, itâ€™s worth some upfront investment to make the problem both easy and fast to reproduce.
- Work with reproducible and minimal examples by removing innocuous code and simplifying data.
- Consider automated testing. Add some nearby tests to ensure that existing good behaviour is preserved. 

### Track the error down.

- Execute code step by step and inspect intermediate outputs. 
- Adopt the scientific method: Generate hypotheses, design experiments to test them, and record your results. 

### Once found, fix the error and test it.

- Ensure you havenâ€™t introduced any new bugs in the process. 
- Make sure to carefully record the correct output, and check against the inputs that previously failed.
- Reset and run again to make sure everything still works. 


---
# Deter

.pull-left-wide2[

### Defensive programming

- **Pay attention.** Do results make sense? Do they look different from previous results? Why?
- **Know what you're doing**, and what you're expecting.
  - Avoid functions that return different types of output depending on their input, e.g., `[]` and `sapply()`.
  - Be strict about what you accept (e.g., only scalars). 
  - Avoid functions that use non-standard evaluation (e.g., `with()`)
- **Fail fast**.
  - As soon as something wrong is discovered, signal an error. 
  - Add tests (e.g., with the `testthat` package).
  - Practice good condition/exception handling, e.g., with `try()` and `tryCatch()`. 
  - Write error messages for humans.

]

.pull-right-small3[
### Transparency

- Collaborate! [Pair programming](https://en.wikipedia.org/wiki/Pair_programming) is an established software development technique that increases code robustness. It also works [from remote](https://ivelasq.rbind.io/blog/vscode-live-share/).
- Be transparent! Let others access your code and comment on it.

&lt;div align="center"&gt;
&lt;img src="pics/pair-programming-its-not-for-everyone.jpeg" width="350"/&gt;
&lt;/div&gt;
]



&lt;!-- ############################################ --&gt;
---
class: inverse, center, middle
name: debuggingr

# Debugging R
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px style="width:1000px; margin:auto;"/&gt;&lt;/html&gt;


---
# What you get

&lt;br&gt;
&lt;br&gt;
&lt;tt&gt;
Error : .onLoad failed in loadNamespace() for 'rJava', details: &lt;br&gt;
call: dyn.load(file, DLLpath = DLLpath, ...) &lt;br&gt;
error: unable to load shared object '/Users/janedoe/Library/R/3.6/library/rJava/libs/rJava.so':  &lt;br&gt;
libjvm.so: cannot open shared object file: No such file or directory  &lt;br&gt;
Error: loading failed  &lt;br&gt;
Execution halted  &lt;br&gt;
ERROR: loading failed  &lt;br&gt;
* removing '/Users/janedoe/Library/R/3.6/library/rJava/' &lt;br&gt;
Warning in install.packages : &lt;br&gt;
installation of package 'rJava' had non-zero exit status
&lt;/tt&gt;

&lt;br&gt;
`Credit` [Jenny Bryan](https://github.com/jennybc/debugging)


---
# What you see


&lt;br&gt;
&lt;br&gt;
&lt;tt&gt;
&lt;span style = "color:red"&gt;Error&lt;/span&gt; : blah &lt;span style = "color:red"&gt;failed&lt;/span&gt; blah blah() blah 'blah', blah: &lt;br&gt;
call: blah.blah(blah, blah = blah, ...) &lt;br&gt;
&lt;span style = "color:red"&gt;error&lt;/span&gt;: &lt;span style = "color:red"&gt;unable&lt;/span&gt; to blah blah blah '/blah/blah/blah/blah/blah/blah/blah/blah/blah.so':  &lt;br&gt;
blah.so: &lt;span style = "color:red"&gt;cannot&lt;/span&gt; open blah blah blah: &lt;span style = "color:red"&gt;No&lt;/span&gt; blah blah blah blah  &lt;br&gt;
&lt;span style = "color:red"&gt;Error&lt;/span&gt;: blah &lt;span style = "color:red"&gt;failed&lt;/span&gt;  &lt;br&gt;
blah blah  &lt;br&gt;
&lt;span style = "color:red"&gt;ERROR&lt;/span&gt;: blah &lt;span style = "color:red"&gt;failed&lt;/span&gt;  &lt;br&gt;
* removing '/blah/blah/blah/blah/blah/blah/blah/' &lt;br&gt;
&lt;span style = "color:red"&gt;Warning&lt;/span&gt; in blah.blah : &lt;br&gt;
blah of blah 'blah' blah blah-blah blah blah
&lt;/tt&gt;

&lt;br&gt;
`Credit` [Jenny Bryan](https://github.com/jennybc/debugging)




---
# Strategies to debug your R code

Sometimes the mistake in your code is hard to diagnose, and googling doesn't help. Here are a couple of strategies to debug your code:

- Use `traceback()` to determine where a given error is occurring.

- Output diagnostic information in code with `print()`, `cat()` or `message()` statements.

- Use `browser()` to open an interactive debugger before the error

- Use `debug()` to automatically open a debugger at the start of a function call.

- Use `trace()` to make temporary code modifications inside a function that you don't have easy access to.


---
# Locating errors with traceback()

.pull-left[

### Motivation and usage
- When an error occurs with an unidentifiable error message or an error message that you are in principle familiar with but cannot locate its sources, the `traceback()` function comes in handy.
- The `traceback()` function prints the sequence of calls that led to an uncaught error.
- The `traceback()` output reads from bottom to top.
- Note that errors caught via `try()` or `tryCatch()` do not generate a traceback!
-  If youâ€™re calling code that you `source()`d into R, the traceback will also display the location of the function, in the form `filename.r#linenumber`. 
]

--

.pull-right[
### Example

In the call sequence below, the execution of `g()` triggers an error:


```r
R&gt; f &lt;- function(x) x + 1
R&gt; g &lt;- function(x) f(x)
R&gt; g("a")
```

```r 
#&gt; Error in x + 1 : non-numeric argument to binary operator
```

Doing the traceback reveals that the function call f(x) is what lead to the error:


```r
R&gt; traceback()
```

```r 
#&gt; 2: f(x) at #1
#&gt; 1: g("a")
```
]

---
# Interactive debugging with browser()

.pull-left[
### Motivation and usage
- Sometimes, you need more information than the precise location of an error in a function to fix it. 
- The interactive debugger lets you pause the run of a function and interactively explore its state.
- Two options to enter the interactive debugger: 
  1. Through RStudio's "Rerun with Debug" tool, shown to the right of an error message.
  2. You can insert a call to `browser()` into the function at the stage where you want to pause, and re-run the function.
- In either case, youâ€™ll end up in an interactive environment inside the function where you can run arbitrary R code to explore the current state. Youâ€™ll know when youâ€™re in the interactive debugger because you get a special prompt, `Browse[1]&gt;`. 
]

--

.pull-right[
### Example


```r
R&gt; h &lt;- function(x) x + 3
R&gt; g &lt;- function(b) {
*+   browser()
+   h(b)
+ }
R&gt; g(10)
```

Some useful things to do are:

1. Use `ls()` to determine what objects are available in the current
   environment.
2. Use `str()`, `print()` etc. to examine the objects.
3. Use `n` to evaluate the next statement.
4. Use `s`: like `n` but also step into function calls.
5. Use `where` to print a stack trace (â†’ traceback).
6. Use `c` to exit debugger and continue execution.
7. Use `Q` to exit debugger and return to the R prompt.
]



---
# Debugging other peoples' code


.pull-left[
### Motivation
- Sometimes the error is outside your code in a package you're using, you might still want to be able to debug.
- Two options:
  1. Download the package code locally and debug it is if it were your own.
  2. Use functions which which allow you to start a browser in existing functions, including `recover()` and `debug()`.
]

.pull-right[
]



---
# Debugging other peoples' code (cont.)

.pull-left-small[
### Motivation
- `recover()` serves as an alternative error handler which you activate by calling `options(error = recover)`.
- You can then select from a list of current calls to browse.
- `options(error = NULL)` turns off this debugging mode again.
- A simpler alternative is `options(error = browser)`, but this only allows you to browse the call where the error occurred.
]

--

.pull-right-wide[
### Example

- Activate debugging mode; then execute (flawed) function:


```r
*R&gt; options(error = recover)
R&gt; lm(mpg ~ wt, data = "mtcars")
```

```r 
Error in model.frame.default(formula = mpg ~ wt, data = "mtcars", drop.unused.levels = TRUE) 
 'data' must be a data.frame, environment, or list
 
Enter a frame number, or 0 to exit   

1: lm(mpg ~ wt, data = "mtcars")
2: eval(mf, parent.frame())
3: eval(mf, parent.frame())

Selection: 
```

- Deactivate debugging mode: 


```r
*R&gt; options(error = NULL)
```
]

---
# Debugging other peoples' code (cont.)

.pull-left[
### Motivation
- `debug()` activates the debugger on any function, including those in packages (see on the right). `undebug()` deactivates the debugger again.
- Some functions in another package are easier to find than others. There are
  - *exported* functions which are available outside of a package and
  - *internal* functions which are only available within a package.
- To find (and debug) exported functions, use the `::` syntax, as in `ggplot2::ggplot`.
- To find un-exported functions, use the `:::` syntax, as in `ggplot2:::check_required_aesthetics`.
]

--

.pull-right[
### Example

- Activate debugging mode for `lm()` function; then execute function:


```r
*R&gt; debug(stats::lm)
R&gt; lm(mpg ~ weight, data = "mtcars")
```

- Interactive debugging mode for `lm()` is entered; use the common `browser()` functionality to navigate:

```r 
debugging in: lm(mpg ~ weight, data = mtcars)
debug: {
    ret.x &lt;- x
    ...
Browse[2]&gt; 
```

- Deactivate debugging mode: 


```r
*R&gt; undebug(stats::lm)
```
]


---
# Debugging in RStudio

&lt;div align="center"&gt;
&lt;img src="pics/rstudio-debug-mode.png" width="1100"/&gt;
&lt;/div&gt;



---
# More on debugging R

.pull-left[
&lt;br&gt;&lt;br&gt;&lt;br&gt;

### Further reading

- [12-minute video](https://vimeo.com/99375765) on debugging in R
- Jenny Bryan's [talk on debugging](https://github.com/jennybc/debugging) at  rstudio::conf 2020
- Jenny Bryan and Jim Hester's "What They Forgot to Teach You About R", Chapter 11: [Debugging R code](https://rstats.wtf/debugging-r-code.html)
- Jonathan McPherson's [Debugging with RStudio](https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio)
]

.pull-right[
&lt;br&gt;
&lt;div align="center"&gt;
&lt;img src="pics/classy-bear-debugging.jpeg" width="450"/&gt;
&lt;/div&gt;
]


---
# Next steps

&lt;br&gt;

### Assignment

Assignment 2 is online soon! You'll have more time than usual to work on it - final upload deadline is Oct 11.

### Next lecture (not next week, but on Oct 10!)

**Relational databases and SQL.** Buckle up and bring coffee, because it'll get both exciting and tedious at the same time.




    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"hash": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
